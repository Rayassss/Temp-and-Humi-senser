C51 COMPILER V9.59.0.0   LCD                                                               08/15/2020 17:37:24 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE LCD
OBJECT MODULE PLACED IN .\Objects\Lcd.obj
COMPILER INVOKED BY: D:\KEIL5_5.29\C51\BIN\C51.EXE Hardware\Lcd.c LARGE ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\U
                    -ser;.\System;.\Hardware;.\System;.\User) DEBUG OBJECTEXTEND PRINT(.\Listings\Lcd.lst) TABS(2) OBJECT(.\Objects\Lcd.obj)

line level    source

   1          #include "STC8F.h"
   2          #include "Lcd.h"
   3          #include "absacc.h"
   4          #include "intrins.h"
   5          #include "string.h"
   6          #include "AsciiLib.h"
   7          #include "Delay.h"
   8          #include "Font.h"
   9          //sbit bl        =P4^4;//接模块BL引脚，背光可以采用IO控制或者PWM控制，也可以直接接到高电平常亮
  10          sbit scl       =P1^1;//接模块CLK引脚,接裸屏Pin9_SCL
  11          sbit sda       =P1^2;//接模块DIN/MOSI引脚，接裸屏Pin8_SDA
  12          sbit rs        =P1^3;//接模块D/C引脚，接裸屏Pin7_A0
  13          sbit cs        =P1^0;//接模块CE引脚，接裸屏Pin12_CS
  14          sbit reset     =P1^4;//接模块RST引脚，接裸屏Pin6_RES
  15          void delay(unsigned int time)
  16          {
  17   1       unsigned int i,j;
  18   1        for(i=0;i<time;i++)
  19   1         for(j=0;j<250;j++);
  20   1      }
  21          
  22          //向SPI总线传输一个8位数据
  23          void  SPI_WriteData(unsigned char Data)
  24          {
  25   1        unsigned char i=0;
  26   1        for(i=8;i>0;i--)
  27   1        {
  28   2          if(Data&0x80) 
  29   2          sda=1; //输出数据
  30   2          else sda=0;
  31   2          scl=0;
  32   2          scl=1;
  33   2          Data<<=1;
  34   2        }
  35   1      }
  36          //向液晶屏写一个8位指令
  37          void  Lcd_WriteIndex(unsigned char Data)
  38          { 
  39   1          cs=0;
  40   1          rs=0;
  41   1          SPI_WriteData(Data);    
  42   1          cs=1;
  43   1      }
  44          //向液晶屏写一个8位数据
  45          void  Lcd_WriteData(unsigned char Data)
  46          { 
  47   1          unsigned char i=0;
  48   1          cs=0;
  49   1          rs=1;
  50   1          SPI_WriteData(Data);  
  51   1          cs=1;
  52   1      }
  53          //向液晶屏写一个16位数据
  54          void  Lcd_WriteData_16(unsigned int Data)
C51 COMPILER V9.59.0.0   LCD                                                               08/15/2020 17:37:24 PAGE 2   

  55          {
  56   1        unsigned char i=0;
  57   1        cs=0;
  58   1        rs=1;
  59   1        SPI_WriteData(Data>>8);   //写入高8位数据
  60   1        SPI_WriteData(Data);      //写入低8位数据
  61   1        cs=1;
  62   1      
  63   1      }
  64          //LCD复位时序
  65          void Reset(void)
  66          {
  67   1          reset=0;
  68   1          delay(100);
  69   1          reset=1;
  70   1          delay(100);
  71   1      }
  72          //////////////////////////////////////////////////////////////////////////////////////////////
  73          //液晶屏初始化 for S6D02A1
  74          void lcd_initial()
  75          {
  76   1        Reset();//Reset before LCD Init.
  77   1          
  78   1        //LCD Init For 1.44Inch LCD Panel with ST7735R.
  79   1        Lcd_WriteIndex(0x11);//Sleep exit 
  80   1        delay (120);
  81   1          
  82   1        //ST7735R Frame Rate
  83   1        Lcd_WriteIndex(0xB1); 
  84   1        Lcd_WriteData(0x01); 
  85   1        Lcd_WriteData(0x2C); 
  86   1        Lcd_WriteData(0x2D); 
  87   1      
  88   1        Lcd_WriteIndex(0xB2); 
  89   1        Lcd_WriteData(0x01); 
  90   1        Lcd_WriteData(0x2C); 
  91   1        Lcd_WriteData(0x2D); 
  92   1      
  93   1        Lcd_WriteIndex(0xB3); 
  94   1        Lcd_WriteData(0x01); 
  95   1        Lcd_WriteData(0x2C); 
  96   1        Lcd_WriteData(0x2D); 
  97   1        Lcd_WriteData(0x01); 
  98   1        Lcd_WriteData(0x2C); 
  99   1        Lcd_WriteData(0x2D); 
 100   1        
 101   1        Lcd_WriteIndex(0xB4); //Column inversion 
 102   1        Lcd_WriteData(0x07); 
 103   1        
 104   1        //ST7735R Power Sequence
 105   1        Lcd_WriteIndex(0xC0); 
 106   1        Lcd_WriteData(0xA2); 
 107   1        Lcd_WriteData(0x02); 
 108   1        Lcd_WriteData(0x84); 
 109   1        Lcd_WriteIndex(0xC1); 
 110   1        Lcd_WriteData(0xC5); 
 111   1      
 112   1        Lcd_WriteIndex(0xC2); 
 113   1        Lcd_WriteData(0x0A); 
 114   1        Lcd_WriteData(0x00); 
 115   1      
 116   1        Lcd_WriteIndex(0xC3); 
C51 COMPILER V9.59.0.0   LCD                                                               08/15/2020 17:37:24 PAGE 3   

 117   1        Lcd_WriteData(0x8A); 
 118   1        Lcd_WriteData(0x2A); 
 119   1        Lcd_WriteIndex(0xC4); 
 120   1        Lcd_WriteData(0x8A); 
 121   1        Lcd_WriteData(0xEE); 
 122   1        
 123   1        Lcd_WriteIndex(0xC5); //VCOM 
 124   1        Lcd_WriteData(0x0E); 
 125   1        
 126   1        Lcd_WriteIndex(0x36); //MX, MY, RGB mode 
 127   1        Lcd_WriteData(0xC0); 
 128   1        
 129   1        //ST7735R Gamma Sequence
 130   1        Lcd_WriteIndex(0xe0); 
 131   1        Lcd_WriteData(0x0f); 
 132   1        Lcd_WriteData(0x1a); 
 133   1        Lcd_WriteData(0x0f); 
 134   1        Lcd_WriteData(0x18); 
 135   1        Lcd_WriteData(0x2f); 
 136   1        Lcd_WriteData(0x28); 
 137   1        Lcd_WriteData(0x20); 
 138   1        Lcd_WriteData(0x22); 
 139   1        Lcd_WriteData(0x1f); 
 140   1        Lcd_WriteData(0x1b); 
 141   1        Lcd_WriteData(0x23); 
 142   1        Lcd_WriteData(0x37); 
 143   1        Lcd_WriteData(0x00);  
 144   1        Lcd_WriteData(0x07); 
 145   1        Lcd_WriteData(0x02); 
 146   1        Lcd_WriteData(0x10); 
 147   1      
 148   1        Lcd_WriteIndex(0xe1); 
 149   1        Lcd_WriteData(0x0f); 
 150   1        Lcd_WriteData(0x1b); 
 151   1        Lcd_WriteData(0x0f); 
 152   1        Lcd_WriteData(0x17); 
 153   1        Lcd_WriteData(0x33); 
 154   1        Lcd_WriteData(0x2c); 
 155   1        Lcd_WriteData(0x29); 
 156   1        Lcd_WriteData(0x2e); 
 157   1        Lcd_WriteData(0x30); 
 158   1        Lcd_WriteData(0x30); 
 159   1        Lcd_WriteData(0x39); 
 160   1        Lcd_WriteData(0x3f); 
 161   1        Lcd_WriteData(0x00); 
 162   1        Lcd_WriteData(0x07); 
 163   1        Lcd_WriteData(0x03); 
 164   1        Lcd_WriteData(0x10);  
 165   1        
 166   1        Lcd_WriteIndex(0x2a);
 167   1        Lcd_WriteData(0x00);
 168   1        Lcd_WriteData(0x00+2);
 169   1        Lcd_WriteData(0x00);
 170   1        Lcd_WriteData(0x80+2);
 171   1      
 172   1        Lcd_WriteIndex(0x2b);
 173   1        Lcd_WriteData(0x00);
 174   1        Lcd_WriteData(0x00+3);
 175   1        Lcd_WriteData(0x00);
 176   1        Lcd_WriteData(0x80+3);
 177   1        
 178   1        Lcd_WriteIndex(0xF0); //Enable test command  
C51 COMPILER V9.59.0.0   LCD                                                               08/15/2020 17:37:24 PAGE 4   

 179   1        Lcd_WriteData(0x01); 
 180   1        Lcd_WriteIndex(0xF6); //Disable ram power save mode 
 181   1        Lcd_WriteData(0x00); 
 182   1        
 183   1        Lcd_WriteIndex(0x3A); //65k mode 
 184   1        Lcd_WriteData(0x05); 
 185   1        
 186   1        
 187   1        Lcd_WriteIndex(0x29);//Display on
 188   1      
 189   1      }
 190          /*************************************************
 191          函数名：LCD_Set_Region
 192          功能：设置lcd显示区域，在此区域写点数据自动换行
 193          入口参数：xy起点和终点
 194          返回值：无
 195          *************************************************/
 196          
 197          //全屏填充函数
 198          void Lcd_SetRegion(unsigned int x_start,unsigned int y_start,unsigned int x_end,unsigned int y_end,unsigne
             -d char mode)//mode是横竖屏模式，1为横屏，2为竖屏
 199          { 
 200   1        if(mode == 2)
 201   1        {
 202   2        Lcd_WriteIndex(0x2a);
 203   2        Lcd_WriteData(0x02);
 204   2        Lcd_WriteData(x_start+2);
 205   2        Lcd_WriteData(0x02);
 206   2        Lcd_WriteData(x_end+2);
 207   2      
 208   2        Lcd_WriteIndex(0x2b);
 209   2        Lcd_WriteData(0x01);
 210   2        Lcd_WriteData(y_start+1);
 211   2        Lcd_WriteData(0x01);
 212   2        Lcd_WriteData(y_end+1);
 213   2        }
 214   1        else if(mode == 1)
 215   1        {
 216   2        Lcd_WriteIndex(0x2a);
 217   2        Lcd_WriteData(0x02);
 218   2        Lcd_WriteData(x_start+2);
 219   2        Lcd_WriteData(0x02);
 220   2        Lcd_WriteData(x_end+2);
 221   2      
 222   2        Lcd_WriteIndex(0x2b);
 223   2        Lcd_WriteData(0x01);
 224   2        Lcd_WriteData(y_start+1);
 225   2        Lcd_WriteData(0x01);
 226   2        Lcd_WriteData(y_end+1); 
 227   2        }
 228   1          //#endif
 229   1        Lcd_WriteIndex(0x2c);
 230   1      }
 231          
 232          
 233          void PutPixel(unsigned int x_start,unsigned int y_start,unsigned int color)
 234          {
 235   1        Lcd_SetRegion(x_start,y_start,x_start+1,y_start+1,2);
 236   1        Lcd_WriteData_16(color);
 237   1      }
 238          void dsp_single_colour(int color)
 239          {
C51 COMPILER V9.59.0.0   LCD                                                               08/15/2020 17:37:24 PAGE 5   

 240   1        unsigned char i,j;
 241   1        Lcd_SetRegion(0,0,128-1,160-1,2);
 242   1        for (i=0;i<160;i++)
 243   1            for (j=0;j<128;j++)
 244   1                Lcd_WriteData_16(color);
 245   1      }
 246          void Dsp_arc_area()
 247          {
 248   1        unsigned char i,j;
 249   1        Lcd_SetRegion(0,0,80,18,2);
 250   1        for (i=0;i<18;i++)
 251   1            for (j=0;j<80;j++)
 252   1                Lcd_WriteData_16(WHITE);
 253   1      }
 254          //显示一个英文字符
 255          void Display_ASCII8X16(unsigned int x0,unsigned int y0,unsigned char *s)
 256          {
 257   1        int i,j,k,x,y,xx;
 258   1        unsigned char qm;
 259   1        long int ulOffset;
 260   1        char  ywbuf[32],temp[2];
 261   1        for(i = 0; i<strlen((unsigned char*)s);i++)
 262   1        {
 263   2          if(((unsigned char)(*(s+i))) >= 161)
 264   2          {
 265   3            temp[0] = *(s+i);
 266   3            temp[1] = '\0';
 267   3          } 
 268   2          else
 269   2          {
 270   3            qm = *(s+i);
 271   3            ulOffset = (long int)(qm) * 16;   
 272   3            for (j = 0; j < 16; j ++)
 273   3            {
 274   4              ywbuf[j]=Zk_ASCII8X16[ulOffset+j];
 275   4            }          
 276   3            for(y = 0;y < 16;y++)
 277   3            {
 278   4                for(x=0;x<8;x++) 
 279   4                {
 280   5                   k=x % 8;             
 281   5                  if(ywbuf[y]&(0x80 >> k))
 282   5                  {
 283   6                    xx=x0+x+i*8;
 284   6                    PutPixel(xx,y+y0,RED);
 285   6                  }           
 286   5                }
 287   4            }
 288   3          }
 289   2        }       
 290   1      }
 291          void LCD_Clear(unsigned int Color)
 292          {
 293   1        unsigned char i,j;
 294   1        Lcd_SetRegion(0,0,127,159,2);
 295   1        for (i=0;i<160;i++)
 296   1        {
 297   2            for (j=0;j<128;j++)
 298   2          {
 299   3                Lcd_WriteData_16(Color);
 300   3          }
 301   2        }
C51 COMPILER V9.59.0.0   LCD                                                               08/15/2020 17:37:24 PAGE 6   

 302   1      }
 303          void Display_Desc()
 304          { 
 305   1          Display_ASCII8X16(10,10,"Dreamix is so so beautiful");
 306   1      }
 307          void go_Lcd()
 308          {
 309   1          lcd_initial();
 310   1          bl=1;
 311   1          dsp_single_colour(WHITE);//白色
 312   1          Display_Desc();         //版本
 313   1      }
 314          //void Lcd_showchar(unsigned char x,unsigned char y,int bgcolor,int Fontcolor)
 315          //{
 316          //  int i = 0,j = 0;
 317          //  unsigned char Temp = 0;
 318          //  Lcd_SetRegion(x,y,x + 79,y + 127,1);
 319          //  for(i=0; i<80*16; i++)
 320          //  {
 321          //    Temp = Font_A[i];
 322          //    for(j=0; j<8; j++)
 323          //    {
 324          //      if(Temp & 0x80)
 325          //      {
 326          //        Lcd_WriteData_16(Fontcolor);
 327          //      }
 328          //      else
 329          //      {
 330          //        Lcd_WriteData_16(bgcolor);
 331          //      }
 332          //      Temp <<= 1;
 333          //    }
 334          //  }
 335          //}
 336          //void GUI_sprintf_Asc_8_16(unsigned char x,unsigned int y,unsigned char value,unsigned int dcolor,unsigne
             -d int bgcolor,unsigned char mode) 
 337          //{  
 338          //  unsigned char i,j;
 339          //  unsigned char *temp=Asc_8_16_;    //temp是*temp的地址  这里temp就是zifu的首地址       
 340          //  temp+=(value-32)*16;   //确定要显示的值
 341          //                   //用ascii表  前32个ascii没有存入zifu库里 所以要减32
 342          //                         //每个字符用16个字节显示 所以在乘以16  就是对应的显示位的首地址
 343          //    if(mode==0)Lcd_SetRegion(x,y,x+7,y+15,1);    //设置区域      
 344          //    if(mode==1)Lcd_SetRegion(x,y,x+7,y+15,1); //设置区域          
 345          //    for(j=0;j<16;j++)
 346          //    {
 347          //      for(i=0;i<8;i++)        //先横扫
 348          //      {          
 349          //        if((*temp&(1<<(7-i)))!=0)      //将1 左移 然后对应位进行相与        
 350          //          Lcd_Write_Data(dcolor);      //显示字符颜色
 351          //         
 352          //        else        
 353          //          Lcd_Write_Data(bgcolor);       //显示背景颜色   
 354          //      }
 355          //      temp++;                  //下一字节
 356          //    }
 357          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1355    ----
   CONSTANT SIZE    =   5404    ----
C51 COMPILER V9.59.0.0   LCD                                                               08/15/2020 17:37:24 PAGE 7   

   XDATA SIZE       =   ----      72
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
